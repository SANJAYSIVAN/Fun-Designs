<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Pendulum</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #ff0055;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            pointer-events: none;
            mix-blend-mode: screen;
            background: rgba(20, 0, 10, 0.8);
            padding: 5px;
            border: 1px solid #ff0055;
        }
        .label {
            font-weight: 700;
            font-size: 20px;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div class="label">Chaos Pendulum</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        
        // Physics State
        let r1 = 125; // Length 1
        let r2 = 125; // Length 2
        let m1 = 10;  // Mass 1
        let m2 = 10;  // Mass 2
        let a1 = Math.PI / 2; // Angle 1
        let a2 = Math.PI / 2; // Angle 2
        let a1_v = 0; // Angular velocity 1
        let a2_v = 0; // Angular velocity 2
        const g = 1;  // Gravity

        let path = [];
        const MAX_PATH = 500;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            reset();
        }

        function reset() {
            path = [];
            a1 = Math.random() * Math.PI * 2;
            a2 = Math.random() * Math.PI * 2;
            a1_v = 0;
            a2_v = 0;
            
            // Clear screen
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
        }

        window.addEventListener('resize', resize);
        window.addEventListener('mousedown', reset);
        
        // Touch reset
        window.addEventListener('touchstart', (e) => {
             e.preventDefault();
             reset();
        });

        resize();

        function draw() {
            // Fade trails
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);

            // Physics Calculation (Runge-Kutta logic simplified for canvas loop)
            // Equations of motion for double pendulum
            
            let num1 = -g * (2 * m1 + m2) * Math.sin(a1);
            let num2 = -m2 * g * Math.sin(a1 - 2 * a2);
            let num3 = -2 * Math.sin(a1 - a2) * m2;
            let num4 = a2_v * a2_v * r2 + a1_v * a1_v * r1 * Math.cos(a1 - a2);
            let den = r1 * (2 * m1 + m2 - m2 * Math.cos(2 * a1 - 2 * a2));
            let a1_a = (num1 + num2 + num3 * num4) / den;

            num1 = 2 * Math.sin(a1 - a2);
            num2 = (a1_v * a1_v * r1 * (m1 + m2));
            num3 = g * (m1 + m2) * Math.cos(a1);
            num4 = a2_v * a2_v * r2 * m2 * Math.cos(a1 - a2);
            den = r2 * (2 * m1 + m2 - m2 * Math.cos(2 * a1 - 2 * a2));
            let a2_a = (num1 * (num2 + num3 + num4)) / den;

            a1_v += a1_a;
            a2_v += a2_a;
            a1 += a1_v;
            a2 += a2_v;
            
            // Damping (friction) to prevent explosion over time
            a1_v *= 0.999;
            a2_v *= 0.999;

            // Positions
            let cx = width / 2;
            let cy = height / 3; // Hang from top third

            let x1 = r1 * Math.sin(a1);
            let y1 = r1 * Math.cos(a1);

            let x2 = x1 + r2 * Math.sin(a2);
            let y2 = y1 + r2 * Math.cos(a2);

            // Shift to center
            x1 += cx; y1 += cy;
            x2 += cx; y2 += cy;

            // Draw Arms (Faint)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Draw Masses
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x1, y1, 8, 0, Math.PI*2);
            ctx.fill();
            
            ctx.fillStyle = '#ff0055';
            ctx.beginPath();
            ctx.arc(x2, y2, 8, 0, Math.PI*2);
            ctx.fill();

            // Store Path
            path.push({x: x2, y: y2});
            if(path.length > MAX_PATH) path.shift();

            // Draw Trail
            ctx.beginPath();
            // Gradient path based on velocity? Or just rainbow cycle
            let speed = Math.sqrt(a2_v*a2_v + a1_v*a1_v) * 100;
            let hue = (speed * 10 + 300) % 360; // Pink/Red range base
            
            ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
            ctx.lineWidth = 3;
            
            // Draw segments
            if (path.length > 1) {
                ctx.moveTo(path[0].x, path[0].y);
                for(let i=1; i<path.length; i++) {
                     ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();
            }

            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>