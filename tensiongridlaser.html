<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tension Grid Dynamics</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        #title {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #FFFFFF;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="title">Tension Grid Dynamics</div>
    <canvas id="canvas"></canvas>

    <script>
        /**
         * Design: Tension Grid Dynamics
         * Logic: Mass-Spring System (Verlet Integration approximation).
         * Aesthetic: Tension mapping to Color (Grey -> Neon Red).
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let points = [];
        let sticks = [];
        let isWeb = false; // Track current mode
        let isDragging = false; // Track if user actually pulled
        
        // Configuration
        const config = {
            cols: 40,
            rows: 30,
            spacing: 30,
            bounce: 0.9,
            gravity: 0.0, // Zero G for abstract feel
            friction: 0.96, // High friction for "snappy" feel
            tensionColorThreshold: 1.2, // Ratio of stretch to trigger red
            mouseInfluenceRadius: 100,
            mouseForce: 5
        };

        const mouse = { x: -1000, y: -1000, down: false };

        class Point {
            constructor(x, y, pinned) {
                this.x = x;
                this.y = y;
                this.oldx = x;
                this.oldy = y;
                this.pinned = pinned;
            }

            update() {
                if (this.pinned) return;

                const vx = (this.x - this.oldx) * config.friction;
                const vy = (this.y - this.oldy) * config.friction;

                this.oldx = this.x;
                this.oldy = this.y;

                this.x += vx;
                this.y += vy;
                this.y += config.gravity;

                // Mouse Interaction (Repulsion/Attraction)
                const dx = this.x - mouse.x;
                const dy = this.y - mouse.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < config.mouseInfluenceRadius) {
                    const force = (config.mouseInfluenceRadius - dist) / config.mouseInfluenceRadius;
                    const dirX = dx / dist;
                    const dirY = dy / dist;
                    
                    const mForce = mouse.down ? -config.mouseForce * 2 : config.mouseForce;

                    this.x += dirX * force * mForce;
                    this.y += dirY * force * mForce;
                }

                // Screen bounds constraints
                if (this.x > width) { this.x = width; this.oldx = this.x + vx * config.bounce; }
                if (this.x < 0) { this.x = 0; this.oldx = this.x + vx * config.bounce; }
                if (this.y > height) { this.y = height; this.oldy = this.y + vy * config.bounce; }
                if (this.y < 0) { this.y = 0; this.oldy = this.y + vy * config.bounce; }
            }

            draw() {
                // Points are tiny white dots
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
            }
        }

        class Stick {
            constructor(p1, p2) {
                this.p1 = p1;
                this.p2 = p2;
                this.length = Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
            }

            update() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Prevent division by zero
                if (dist === 0) return;

                const diff = this.length - dist;
                const percent = diff / dist / 2;
                const offsetX = dx * percent;
                const offsetY = dy * percent;

                if (!this.p1.pinned) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }

            draw() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate tension ratio
                const tension = dist / this.length;

                // Color mapping
                // 1.0 = Rest = Dark Grey
                // > 1.2 = Stretched = Fade to Red
                
                ctx.beginPath();
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);

                if (tension > config.tensionColorThreshold) {
                    // High tension: Neon Red
                    // Map intensity based on how much it is stretched
                    const intensity = Math.min((tension - config.tensionColorThreshold) * 2, 1);
                    ctx.strokeStyle = `rgba(255, 0, 51, ${0.2 + intensity * 0.8})`; // #FF0033
                    ctx.shadowColor = '#FF0033';
                    ctx.shadowBlur = intensity * 15;
                    ctx.lineWidth = 1 + intensity;
                } else {
                    // Low tension: Subtle Grey
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 1;
                }
                
                ctx.stroke();
            }
        }

        function initGrid() {
            points = [];
            sticks = [];
            isWeb = false;
            
            // Calculate grid to center it
            const startX = (width - (config.cols * config.spacing)) / 2;
            const startY = (height - (config.rows * config.spacing)) / 2;

            // Create Points
            for (let y = 0; y <= config.rows; y++) {
                for (let x = 0; x <= config.cols; x++) {
                    const pX = startX + x * config.spacing;
                    const pY = startY + y * config.spacing;
                    // Pin the corners or edges
                    let pinned = false;
                    
                    // Pinning strategy: 4 corners + midpoints of edges
                    if ((y === 0 || y === config.rows) && (x === 0 || x === config.cols)) {
                        pinned = true;
                    }
                    if (y===0 && x === Math.floor(config.cols/2)) pinned = true;
                    if (y===config.rows && x === Math.floor(config.cols/2)) pinned = true;
                    if (x===0 && y === Math.floor(config.rows/2)) pinned = true;
                    if (x===config.cols && y === Math.floor(config.rows/2)) pinned = true;

                    points.push(new Point(pX, pY, pinned));
                }
            }

            // Create Sticks
            for (let y = 0; y <= config.rows; y++) {
                for (let x = 0; x <= config.cols; x++) {
                    const i = y * (config.cols + 1) + x;
                    
                    // Connect right
                    if (x < config.cols) {
                        sticks.push(new Stick(points[i], points[i + 1]));
                    }
                    // Connect down
                    if (y < config.rows) {
                        sticks.push(new Stick(points[i], points[i + config.cols + 1]));
                    }
                }
            }
        }

        function initSpiderWeb() {
            points = [];
            sticks = [];
            const cx = width / 2;
            const cy = height / 2;
            const maxRadius = Math.min(width, height) * 0.45;
            const rings = 12;
            const spokes = 16;

            // 1. Center Point (Index 0)
            const centerPoint = new Point(cx, cy, true); // Pin center strongly
            points.push(centerPoint);

            // 2. Create Points (Polar Coordinates)
            for (let r = 1; r <= rings; r++) {
                const radius = (r / rings) * maxRadius;
                // Add some randomness to initial placement for "organic" pop
                for (let s = 0; s < spokes; s++) {
                    const angle = (s / spokes) * Math.PI * 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    
                    // Pin the outermost ring
                    const pinned = (r === rings);
                    points.push(new Point(x, y, pinned));
                }
            }

            // 3. Create Sticks
            
            // Connect Center to First Ring
            for (let s = 0; s < spokes; s++) {
                // Center is 0. First ring indices start at 1.
                sticks.push(new Stick(points[0], points[1 + s]));
            }

            // Connect Rings (Radial & Spiral)
            for (let r = 1; r <= rings; r++) {
                for (let s = 0; s < spokes; s++) {
                    const currentIdx = 1 + (r - 1) * spokes + s;

                    // Tangential/Spiral Connection (Connect to neighbor in same ring)
                    const nextSpoke = (s + 1) % spokes;
                    const nextTangentialIdx = 1 + (r - 1) * spokes + nextSpoke;
                    sticks.push(new Stick(points[currentIdx], points[nextTangentialIdx]));

                    // Radial Connection (Connect to next outer ring)
                    if (r < rings) {
                        const nextRadialIdx = 1 + r * spokes + s;
                        sticks.push(new Stick(points[currentIdx], points[nextRadialIdx]));
                    }
                }
            }
            
            // Update Title
            const titleEl = document.getElementById('title');
            if(titleEl) titleEl.innerText = "Tension Grid Dynamics (Web Form)";
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (isWeb) {
                initSpiderWeb();
            } else {
                initGrid();
            }
        }

        function update() {
            points.forEach(p => p.update());
            // Iterate sticks multiple times for stiffness (Constraint relaxation)
            for (let i = 0; i < 3; i++) {
                sticks.forEach(s => s.update());
            }
        }

        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);

            // Draw sticks first (behind points)
            sticks.forEach(s => s.draw());

            // Reset shadow for points
            ctx.shadowBlur = 0;
            // Draw points
            points.forEach(p => p.draw());
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // Event Listeners
        window.addEventListener('resize', resize);
        
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            if (mouse.down) {
                isDragging = true;
            }
        });

        window.addEventListener('mousedown', () => {
            mouse.down = true;
            isDragging = false; // Reset drag status
        });

        window.addEventListener('mouseup', () => {
            mouse.down = false;
            // Trigger transformation if user pulled and we haven't transformed yet
            if (isDragging && !isWeb) {
                isWeb = true;
                initSpiderWeb();
            }
            isDragging = false;
        });

        // Start
        resize(); // This defaults to initGrid() since isWeb is false initially
        loop();

    </script>
</body>
</html>