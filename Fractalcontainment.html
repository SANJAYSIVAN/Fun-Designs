<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Containment</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(200, 220, 255, 0.9);
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>
    <div id="info">Fractal Containment</div>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            document.body.innerHTML = '<div style="color:white; padding:20px;">Unable to initialize WebGL.</div>';
        }

        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        const fsSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;

            #define FC gl_FragCoord
            #define r iResolution
            #define t iTime
            #define o gl_FragColor

            mat2 rot(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, s, -s, c);
            }

            // Energy Palette
            vec3 palette(float t) {
                return vec3(0.5, 0.5, 0.5) + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));
            }

            // SDF Primitives
            float sdBox(vec3 p, vec3 b) {
                vec3 q = abs(p) - b;
                return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
            }
            
            // Box Frame (Wireframe cube)
            float sdBoxFrame(vec3 p, vec3 b, float e) {
                p = abs(p)-b;
                vec3 q = abs(p+e)-e;
                return min(min(
                    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
                    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
                    length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
            }

            // The Inner Fractal (Volatile Energy)
            float mapFractal(vec3 p) {
                vec3 q = p;
                float d = 100.0;
                float scale = 1.0;
                
                // Rotate inside the box
                q.xy *= rot(t * 0.5);
                q.xz *= rot(t * 0.3);
                
                // KIFS Folding
                for(int i=0; i<4; i++) {
                    q = abs(q) - vec3(0.4, 0.8, 0.4); // Expanding fold
                    q.xy *= rot(0.5 + sin(t)*0.2); // Breathing motion
                    q.xz *= rot(0.3);
                    
                    scale *= 1.3;
                    d = min(d, length(q)/scale);
                }
                
                // Distance to thin filaments
                return d - 0.01;
            }

            // Scene Map
            // Returns vec2(distance, materialID)
            vec2 map(vec3 p) {
                // 1. Outer Containment Frame (Metal)
                float frame = sdBoxFrame(p, vec3(1.5), 0.1);
                
                // 2. Glass Walls (Box)
                // Slightly smaller than frame
                float glass = sdBox(p, vec3(1.45));
                
                // 3. Inner Fractal (Energy)
                float frac = mapFractal(p);
                
                // Combine: Frame is solid
                float d = frame;
                
                return vec2(d, 1.0);
            }

            void main() {
                vec2 uv = (FC.xy * 2.0 - r) / min(r.y, r.x);
                
                // Camera: Orbiting
                float dist = 5.0;
                vec3 ro = vec3(sin(t * 0.3) * dist, 2.0, cos(t * 0.3) * dist); 
                vec3 target = vec3(0.0, 0.0, 0.0);
                
                vec3 fwd = normalize(target - ro);
                vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));
                vec3 up = cross(right, fwd);
                vec3 rd = normalize(fwd * 1.5 + right * uv.x + up * uv.y);

                // Background: Clean Lab Grey
                vec3 col = mix(vec3(0.1, 0.12, 0.15), vec3(0.05, 0.05, 0.08), length(uv));
                
                float totalDist = 0.0;
                
                // Accumulators
                vec3 glow = vec3(0.0);
                vec3 glassReflect = vec3(0.0);
                float glassAlpha = 0.0;
                
                bool passedGlass = false;
                
                for(int i = 0; i < 90; i++) {
                    vec3 p = ro + rd * totalDist;
                    
                    // Check solids (Frame)
                    vec2 res = map(p);
                    float dSolid = res.x;
                    
                    // Check Glass
                    float dGlass = sdBox(p, vec3(1.45));
                    float glassDist = abs(dGlass) - 0.01; // Thin shell
                    
                    // Check Fractal (Volumetric)
                    float dFractal = mapFractal(p);
                    
                    // -- Volumetric Glow Accumulation --
                    if(dGlass < 0.0) {
                        vec3 energyCol = palette(length(p)*2.0 - t*2.0);
                        float intensity = 0.001 / (0.0002 + dFractal*dFractal);
                        glow += energyCol * intensity;
                    }
                    
                    // -- Glass Surface Interaction --
                    if(glassDist < 0.01 && !passedGlass && totalDist > 0.1) {
                        passedGlass = true;
                        
                        // Calculate Glass Reflection (Fake)
                        vec3 n = normalize(p); // Box normal approx
                        // FIXED: Explicit floats in vector constructors
                        vec3 absP = abs(p);
                        if(absP.x > absP.y && absP.x > absP.z) n = vec3(sign(p.x), 0.0, 0.0);
                        else if(absP.y > absP.z) n = vec3(0.0, sign(p.y), 0.0);
                        else n = vec3(0.0, 0.0, sign(p.z));
                        
                        vec3 ref = reflect(rd, n);
                        
                        // Environment reflection on glass
                        float env = smoothstep(0.0, 1.0, ref.y);
                        glassReflect += vec3(0.8, 0.9, 1.0) * env * 0.3;
                        
                        // Specular glint
                        float spec = pow(max(0.0, dot(ref, normalize(vec3(1.0,1.0,1.0)))), 32.0);
                        glassReflect += vec3(1.0) * spec * 0.8;
                        
                        glassAlpha = 0.2; 
                    }
                    
                    // -- Solid Hit (Frame) --
                    if(dSolid < 0.001) {
                        // Material: Brushed Steel
                        vec3 mat = vec3(0.3, 0.3, 0.35);
                        
                        vec3 e = vec3(0.001, 0.0, 0.0);
                        vec3 n = normalize(vec3(
                            map(p + e).x - map(p - e).x,
                            map(p + e.yxz).x - map(p - e.yxz).x,
                            map(p + e.yzx).x - map(p - e.yzx).x
                        ));
                        
                        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
                        float diff = max(0.0, dot(n, lightDir));
                        float spec = pow(max(0.0, dot(reflect(rd, n), lightDir)), 16.0);
                        
                        vec3 solidCol = mat * (diff + 0.3) + vec3(1.0) * spec;
                        
                        col = solidCol;
                        break;
                    }
                    
                    // Step Forward
                    float stepSize = dSolid;
                    if(dGlass < 0.0) stepSize = max(dFractal * 0.5, 0.05);
                    else stepSize = min(dSolid, max(glassDist, 0.05));
                    
                    totalDist += stepSize;
                    
                    if(totalDist > 20.0) break;
                }

                // Composite
                col += glow * 1.5;
                col = mix(col, glassReflect + col, glassAlpha);
                
                // Outer Glow (Bloom)
                float screenGlow = 1.0 / (length(uv) + 0.5);
                col += vec3(0.0, 0.5, 1.0) * screenGlow * 0.1;
                
                // Vignette
                col *= 1.1 - length(uv) * 0.3;
                
                // Tone Mapping
                col = col / (1.0 + col);
                col = pow(col, vec3(0.4545)); 
                
                o = vec4(col, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        
        if (vertexShader && fragmentShader) {
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            }

            const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            const resolutionLocation = gl.getUniformLocation(shaderProgram, 'iResolution');
            const timeLocation = gl.getUniformLocation(shaderProgram, 'iTime');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                -1.0,  1.0,
                 1.0,  1.0,
                -1.0, -1.0,
                 1.0, -1.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resize);
            resize();

            function render(time) {
                time *= 0.001; // convert to seconds

                gl.useProgram(shaderProgram);

                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(timeLocation, time);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }
    </script>
</body>
</html>