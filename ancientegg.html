<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Egg</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 100, 50, 0.9);
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>
    <div id="info">Dragon Egg</div>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            document.body.innerHTML = '<div style="color:white; padding:20px;">Unable to initialize WebGL.</div>';
        }

        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        const fsSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;

            #define FC gl_FragCoord
            #define r iResolution
            #define t iTime
            #define o gl_FragColor

            mat2 rot(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, s, -s, c);
            }

            // Magma Palette
            vec3 palette(float t) {
                return vec3(1.0, 0.4, 0.1) * (0.8 + 0.2 * cos(t));
            }

            // SDF Primitives
            float sdSphere(vec3 p, float s) {
                return length(p) - s;
            }
            
            float sdTorus(vec3 p, vec2 t) {
                vec2 q = vec2(length(p.xz) - t.x, p.y);
                return length(q) - t.y;
            }

            // Egg Shape (Distorted Sphere)
            float sdEgg(vec3 p, float r) {
                // Squeeze Y to make it oval
                // Adjust Y coordinate based on height to taper the top
                float k = 0.6; // Taper amount
                p.y += 0.5; // Center
                float stretch = 1.2 - 0.2 * p.y;
                return length(vec3(p.x, p.y / 1.4, p.z)) - r;
            }

            // Scene Map
            vec2 map(vec3 p) {
                vec3 q = p;
                
                // Animate Egg (Heartbeat / Wobble)
                float pulse = sin(t * 2.0) * 0.05;
                float wobble = sin(t * 3.0) * 0.02;
                
                q.y -= pulse;
                q.x += wobble;
                
                // 1. The Egg
                float eggBase = sdEgg(q, 1.2);
                
                // Add Scales Texture (Displacement)
                // Use sine waves to simulate overlapping scales
                float scales = sin(q.y * 10.0) * sin(q.x * 10.0 + q.y*5.0) * sin(q.z * 10.0);
                // Make cracks deeper
                float cracks = smoothstep(0.4, 0.6, scales);
                
                float egg = eggBase - 0.02 * scales;
                
                // 2. The Nest (Torus ring of jagged rock)
                vec3 nP = p;
                nP.y += 1.5; // Move down
                
                float nestBase = sdTorus(nP, vec2(2.0, 0.6));
                // Jagged noise for rocks
                float rock = sin(nP.x*5.0)*sin(nP.y*4.0)*sin(nP.z*5.0);
                float nest = nestBase + rock * 0.1;
                
                // 3. Ground
                float ground = p.y + 2.0;
                
                // Combine
                float d = min(egg, nest);
                d = min(d, ground);
                
                // IDs: 1=Egg, 2=Nest/Ground
                if(d == egg) return vec2(d, 1.0);
                return vec2(d, 2.0);
            }

            void main() {
                vec2 uv = (FC.xy * 2.0 - r) / min(r.y, r.x);
                
                // Camera: Orbiting slowly
                vec3 ro = vec3(sin(t * 0.2) * 5.0, 1.0, cos(t * 0.2) * 5.0); 
                vec3 target = vec3(0.0, 0.0, 0.0);
                
                vec3 fwd = normalize(target - ro);
                vec3 right = normalize(cross(fwd, vec3(0.0, 1.0, 0.0)));
                vec3 up = cross(right, fwd);
                vec3 rd = normalize(fwd * 2.0 + right * uv.x + up * uv.y); // Telephoto

                // Background: Dark Cave
                vec3 col = vec3(0.02, 0.01, 0.0);
                
                float totalDist = 0.0;
                vec2 res = vec2(0.0);
                
                for(int i = 0; i < 90; i++) {
                    vec3 p = ro + rd * totalDist;
                    res = map(p);
                    float d = res.x;
                    
                    if(d < 0.002) {
                        // Calculate Normal
                        vec2 e = vec2(0.005, 0.0);
                        vec3 n = normalize(vec3(
                            map(p + e.xyy).x - map(p - e.xyy).x,
                            map(p + e.yxy).x - map(p - e.yxy).x,
                            map(p + e.yyx).x - map(p - e.yyx).x
                        ));
                        
                        // Lighting Setup
                        // Internal Glow (The Egg is the light source)
                        vec3 eggPos = vec3(0.0, 0.0, 0.0);
                        vec3 lightDir = normalize(eggPos - p); // Light comes from egg center? No, emitted.
                        
                        // Main Key Light (Top down warm)
                        vec3 keyLight = normalize(vec3(0.5, 1.0, 0.5));
                        float diff = max(0.0, dot(n, keyLight));
                        
                        // Rim Light (Backlight)
                        float rim = pow(1.0 + dot(rd, n), 3.0);
                        
                        // Hit Egg?
                        if(res.y == 1.0) {
                            // Material: Black Obsidian Scales
                            vec3 mat = vec3(0.05, 0.05, 0.07); 
                            
                            // Magma Cracks
                            // Re-calculate scale pattern to find cracks
                            // Move pattern with time for flowing lava effect
                            vec3 q = p;
                            q.y -= sin(t * 2.0) * 0.05; // Sync with movement
                            float pattern = sin(q.y * 10.0) * sin(q.x * 10.0 + q.y*5.0) * sin(q.z * 10.0);
                            
                            // Cracks are where pattern is low
                            float crack = smoothstep(-0.2, -0.6, pattern);
                            
                            // Pulse heat
                            float pulse = 0.8 + 0.4 * sin(t * 4.0);
                            vec3 magma = vec3(1.0, 0.3, 0.0) * crack * pulse * 3.0;
                            
                            // Specular (Shiny scales)
                            float spec = pow(max(0.0, dot(reflect(rd, n), keyLight)), 32.0);
                            
                            col = mat * (diff + 0.2);
                            col += magma; // Add emission
                            col += vec3(1.0) * spec * (1.0 - crack); // Only scales shine
                            col += vec3(0.5, 0.2, 0.0) * rim * 0.5;
                        } 
                        // Hit Nest?
                        else {
                            // Material: Grey Rock / Ash
                            vec3 mat = vec3(0.1, 0.1, 0.12);
                            
                            // Lighting from Egg (Fake point light)
                            // Distance to egg center
                            float distToEgg = length(p - vec3(0.0, 0.0, 0.0));
                            float eggLight = 1.0 / (distToEgg * distToEgg * 0.5 + 0.1);
                            vec3 eggColor = vec3(1.0, 0.4, 0.0);
                            
                            // Pulse light
                            float pulse = 0.8 + 0.2 * sin(t * 4.0);
                            
                            // Shadows (AO based on normal)
                            float ao = 0.5 + 0.5 * n.y;
                            
                            col = mat * (diff * 0.2 + 0.1); // Dim ambient
                            col += mat * eggLight * eggColor * pulse * max(0.0, dot(n, normalize(vec3(0.0)-p))); // Egg casting light
                        }
                        
                        break;
                    }
                    
                    totalDist += d * 0.5;
                    if(totalDist > 20.0) break;
                }
                
                // Glow (Atmosphere)
                // Screen space glow centered on egg
                vec3 pScreen = ro + rd * totalDist;
                float eggDist2 = length(cross(ro, rd)); // Distance ray to center (approx)
                // Better: simple 2D glow
                float glow = 1.0 / (length(uv) + 0.2);
                // Pulse
                float pulse = 0.8 + 0.2 * sin(t * 4.0);
                
                col += vec3(1.0, 0.3, 0.0) * glow * 0.1 * pulse;

                // Vignette
                col *= 1.1 - length(uv) * 0.4;
                
                // Color Grading
                col = pow(col, vec3(0.9)); 
                col = smoothstep(0.0, 1.0, col);
                
                o = vec4(col, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        
        if (vertexShader && fragmentShader) {
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            }

            const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            const resolutionLocation = gl.getUniformLocation(shaderProgram, 'iResolution');
            const timeLocation = gl.getUniformLocation(shaderProgram, 'iTime');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                -1.0,  1.0,
                 1.0,  1.0,
                -1.0, -1.0,
                 1.0, -1.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resize);
            resize();

            function render(time) {
                time *= 0.001; // convert to seconds

                gl.useProgram(shaderProgram);

                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(timeLocation, time);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                requestAnimationFrame(render);
            }

            requestAnimationFrame(render);
        }
    </script>
</body>
</html>